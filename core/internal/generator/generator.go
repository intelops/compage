package generator

import (
	"context"
	"errors"
	"fmt"
	"github.com/intelops/compage/core/internal/core"
	"github.com/intelops/compage/core/internal/languages"
	"github.com/intelops/compage/core/internal/languages/golang"
	"github.com/intelops/compage/core/internal/utils"
	log "github.com/sirupsen/logrus"
	"os"
	"strings"
)

// Generator called from rest as well as gRPC
func Generator(coreProject *core.Project) error {
	// create a directory with project name to contain code generated by core.
	projectDirectory := utils.GetProjectDirectoryName(coreProject.Name)
	if err := utils.CreateDirectories(projectDirectory); err != nil {
		return err
	}

	// Iterate over all nodes and generate code for all nodes.
	compageJson := coreProject.CompageJson
	for _, compageNode := range compageJson.Nodes {
		log.Debugf("processing node ID : %s ", compageNode.ID)
		// convert node to languageNode
		languageNode, err1 := languages.NewLanguageNode(compageJson, compageNode)
		if err1 != nil {
			// return errors like certain protocols aren't yet supported
			return err1
		}
		// add values to context.
		ctx := languages.AddValuesToContext(context.Background(), coreProject, languageNode)
		// check for the templates
		if compageNode.ConsumerData.Template == languages.Compage {
			// if language is not set, consider that the node is go project
			if compageNode.ConsumerData.Language == "" || compageNode.ConsumerData.Language == languages.Go {
				// generate golang project using custom template.
				if err2 := golang.Generator(ctx); err2 != nil {
					return err2
				}
				// trigger template runner
				// create data map with values from LanguageNode and project to replace placeholders  - this is required as the
				// names may be conflicting in nature
				values := ctx.Value(languages.ContextVars).(languages.Values)
				nodeDirectoryName := values.NodeDirectoryName
				err := RunGoFmt(nodeDirectoryName)
				if err != nil {
					return err
				}
			} else {
				return errors.New("unsupported language : " + compageNode.ConsumerData.Language)
			}
		} else if compageNode.ConsumerData.Template == languages.OpenApi {
			values := ctx.Value(languages.ContextVars).(languages.Values)
			nodeDirectoryName := values.NodeDirectoryName
			// create node directory in projectDirectory depicting a subproject
			if err := utils.CreateDirectories(nodeDirectoryName); err != nil {
				return err
			}
			// copy relevant files from templates based on config received, if the node is server
			if languageNode.RestConfig != nil && len(languageNode.RestConfig.Server.OpenApiFileYamlContent) > 0 {
				fileName, err := writeFile(languageNode.RestConfig.Server.OpenApiFileYamlContent)
				if err != nil {
					return err
				}
				// generate code by openapi.yaml
				err = RunOpenApiGenerator("generate", "-i", fileName, "-g", strings.ToLower(languageNode.RestConfig.Server.Framework), "-o", nodeDirectoryName, "--git-user-id", coreProject.UserName, "--git-repo-id", coreProject.RepositoryName+"/"+compageNode.ConsumerData.Name)
				if err != nil {
					return errors.New("something happened while running openApi generator")
				}
				// generate documentation for the code
				err = RunOpenApiGenerator("generate", "-i", fileName, "-g", "dynamic-html", "-o", nodeDirectoryName+"/gen/docs", "--git-user-id", coreProject.UserName, "--git-repo-id", coreProject.RepositoryName+"/"+compageNode.ConsumerData.Name)
				if err != nil {
					return errors.New("something happened while running openApi generator for documentation.")
				}
				// copy kubernetes yaml's
			} else {
				return errors.New("at least rest-config needs to be provided, OpenApiFileYamlContent is empty")
			}
		} else {
			// frameworks cli tools
			return errors.New(fmt.Sprintf("unsupported template for language : %s", languages.Go))
		}
	}

	return nil
}

func writeFile(content string) (string, error) {
	file, err := os.CreateTemp("/tmp", "openapi")
	if err != nil {
		return "", err
	}

	defer func(f *os.File) {
		_ = f.Close()
	}(file)
	_, err = file.WriteString(content)
	return file.Name(), err
}
